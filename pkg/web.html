<!DOCTYPE html>
<html>
<head>
<title>Twister: web</title>
<link rel="stylesheet" href="../static/base.css" type="text/css"/> 
</head>
<body>
<div id="content"> 
<h1><a href="..">Twister</a>: web</h1>

<h4>Table Of Contents</h4>
<ul>
<li><a href="#package">Package</a>
<li><a href="#constants">Constants</a>
<li><a href="#variables">Variables</a>
<li><a href="#FilterRespond">func FilterRespond</a>
<li><a href="#FormatDeltaDays">func FormatDeltaDays</a>
<li><a href="#FormatDeltaSeconds">func FormatDeltaSeconds</a>
<li><a href="#HTMLEscapeString">func HTMLEscapeString</a>
<li><a href="#HeaderName">func HeaderName</a>
<li><a href="#HeaderNameBytes">func HeaderNameBytes</a>
<li><a href="#ParseMultipartForm">func ParseMultipartForm</a>
<li><a href="#ProtocolVersion">func ProtocolVersion</a>
<li><a href="#QuoteHeaderValue">func QuoteHeaderValue</a>
<li><a href="#QuoteHeaderValueOrToken">func QuoteHeaderValueOrToken</a>
<li><a href="#RunHandler">func RunHandler</a>
<li><a href="#SignValue">func SignValue</a>
<li><a href="#StatusText">func StatusText</a>
<li><a href="#UnquoteHeaderValue">func UnquoteHeaderValue</a>
<li><a href="#VerifyValue">func VerifyValue</a>
<li><a href="#Cookie">type Cookie</a>
        <ul>
    <li><a href="#NewCookie">func NewCookie</a>
    <li><a href="#Cookie.Delete">func (*Cookie) Delete</a>
    <li><a href="#Cookie.Domain">func (*Cookie) Domain</a>
    <li><a href="#Cookie.HTTPOnly">func (*Cookie) HTTPOnly</a>
    <li><a href="#Cookie.MaxAge">func (*Cookie) MaxAge</a>
    <li><a href="#Cookie.MaxAgeDays">func (*Cookie) MaxAgeDays</a>
    <li><a href="#Cookie.Path">func (*Cookie) Path</a>
    <li><a href="#Cookie.Secure">func (*Cookie) Secure</a>
    <li><a href="#Cookie.String">func (*Cookie) String</a>
        </ul>
<li><a href="#ErrorHandler">type ErrorHandler</a>
<li><a href="#Handler">type Handler</a>
        <ul>
    <li><a href="#DirectoryHandler">func DirectoryHandler</a>
    <li><a href="#FileHandler">func FileHandler</a>
    <li><a href="#FormHandler">func FormHandler</a>
    <li><a href="#NotFoundHandler">func NotFoundHandler</a>
    <li><a href="#ProcessForm">func ProcessForm</a>
    <li><a href="#ProxyHeaderHandler">func ProxyHeaderHandler</a>
    <li><a href="#RedirectHandler">func RedirectHandler</a>
    <li><a href="#SetErrorHandler">func SetErrorHandler</a>
        </ul>
<li><a href="#HandlerFunc">type HandlerFunc</a>
            <ul>
    <li><a href="#HandlerFunc.ServeWeb">func (HandlerFunc) ServeWeb</a>
            </ul>
<li><a href="#HeaderMap">type HeaderMap</a>
        <ul>
    <li><a href="#NewHeaderMap">func NewHeaderMap</a>
    <li><a href="#HeaderMap.Add">func (HeaderMap) Add</a>
    <li><a href="#HeaderMap.Get">func (HeaderMap) Get</a>
    <li><a href="#HeaderMap.GetList">func (HeaderMap) GetList</a>
    <li><a href="#HeaderMap.GetValueParam">func (HeaderMap) GetValueParam</a>
    <li><a href="#HeaderMap.ParseHttpHeader">func (HeaderMap) ParseHttpHeader</a>
    <li><a href="#HeaderMap.ParseHttpHeaderBytes">func (HeaderMap) ParseHttpHeaderBytes</a>
    <li><a href="#HeaderMap.Set">func (HeaderMap) Set</a>
    <li><a href="#HeaderMap.WriteHttpHeader">func (HeaderMap) WriteHttpHeader</a>
        </ul>
<li><a href="#HostRouter">type HostRouter</a>
        <ul>
    <li><a href="#NewHostRouter">func NewHostRouter</a>
    <li><a href="#HostRouter.Register">func (*HostRouter) Register</a>
    <li><a href="#HostRouter.ServeWeb">func (*HostRouter) ServeWeb</a>
        </ul>
<li><a href="#ParamMap">type ParamMap</a>
        <ul>
    <li><a href="#NewParamMap">func NewParamMap</a>
    <li><a href="#ParamMap.Add">func (ParamMap) Add</a>
    <li><a href="#ParamMap.FormEncodedBytes">func (ParamMap) FormEncodedBytes</a>
    <li><a href="#ParamMap.FormEncodedString">func (ParamMap) FormEncodedString</a>
    <li><a href="#ParamMap.Get">func (ParamMap) Get</a>
    <li><a href="#ParamMap.ParseFormEncodedBytes">func (ParamMap) ParseFormEncodedBytes</a>
    <li><a href="#ParamMap.Set">func (ParamMap) Set</a>
    <li><a href="#ParamMap.StringMap">func (ParamMap) StringMap</a>
        </ul>
<li><a href="#Part">type Part</a>
<li><a href="#Request">type Request</a>
        <ul>
    <li><a href="#NewRequest">func NewRequest</a>
    <li><a href="#Request.BodyBytes">func (*Request) BodyBytes</a>
    <li><a href="#Request.Error">func (*Request) Error</a>
    <li><a href="#Request.ParseForm">func (*Request) ParseForm</a>
    <li><a href="#Request.Redirect">func (*Request) Redirect</a>
    <li><a href="#Request.Respond">func (*Request) Respond</a>
        </ul>
<li><a href="#RequestBody">type RequestBody</a>
<li><a href="#Responder">type Responder</a>
<li><a href="#ResponseBody">type ResponseBody</a>
<li><a href="#Router">type Router</a>
        <ul>
    <li><a href="#NewRouter">func NewRouter</a>
    <li><a href="#Router.Register">func (*Router) Register</a>
    <li><a href="#Router.ServeWeb">func (*Router) ServeWeb</a>
        </ul>
</ul>

<h2 id="package">Package</h2>

<p><code>import "github.com/garyburd/twister/web"</code></p>

<p>
The web package defines the application programming interface to a web
server and implements functionality common to many web applications.
</p>


<h2 id="constants">Constants</h2>
<p>
Name of XSRF cookie and request parameter.
</p>

<pre>
const (
 XSRFCookieName = &#34;xsrf&#34;
 XSRFParamName  = &#34;xsrf&#34;
)
</pre>
<p>
Header names in canonical format.
</p>

<pre>
const (
 HeaderAccept               = &#34;Accept&#34;
 HeaderAcceptCharset        = &#34;Accept-Charset&#34;
 HeaderAcceptEncoding       = &#34;Accept-Encoding&#34;
 HeaderAcceptLanguage       = &#34;Accept-Language&#34;
 HeaderAcceptRanges         = &#34;Accept-Ranges&#34;
 HeaderAge                  = &#34;Age&#34;
 HeaderAllow                = &#34;Allow&#34;
 HeaderAuthorization        = &#34;Authorization&#34;
 HeaderCacheControl         = &#34;Cache-Control&#34;
 HeaderConnection           = &#34;Connection&#34;
 HeaderContentDisposition   = &#34;Content-Disposition&#34;
 HeaderContentEncoding      = &#34;Content-Encoding&#34;
 HeaderContentLanguage      = &#34;Content-Language&#34;
 HeaderContentLength        = &#34;Content-Length&#34;
 HeaderContentLocation      = &#34;Content-Location&#34;
 HeaderContentMD5           = &#34;Content-Md5&#34;
 HeaderContentRange         = &#34;Content-Range&#34;
 HeaderContentType          = &#34;Content-Type&#34;
 HeaderCookie               = &#34;Cookie&#34;
 HeaderDate                 = &#34;Date&#34;
 HeaderETag                 = &#34;Etag&#34;
 HeaderEtag                 = &#34;Etag&#34;
 HeaderExpect               = &#34;Expect&#34;
 HeaderExpires              = &#34;Expires&#34;
 HeaderFrom                 = &#34;From&#34;
 HeaderHost                 = &#34;Host&#34;
 HeaderIfMatch              = &#34;If-Match&#34;
 HeaderIfModifiedSince      = &#34;If-Modified-Since&#34;
 HeaderIfNoneMatch          = &#34;If-None-Match&#34;
 HeaderIfRange              = &#34;If-Range&#34;
 HeaderIfUnmodifiedSince    = &#34;If-Unmodified-Since&#34;
 HeaderLastModified         = &#34;Last-Modified&#34;
 HeaderLocation             = &#34;Location&#34;
 HeaderMaxForwards          = &#34;Max-Forwards&#34;
 HeaderOrigin               = &#34;Origin&#34;
 HeaderPragma               = &#34;Pragma&#34;
 HeaderProxyAuthenticate    = &#34;Proxy-Authenticate&#34;
 HeaderProxyAuthorization   = &#34;Proxy-Authorization&#34;
 HeaderRange                = &#34;Range&#34;
 HeaderReferer              = &#34;Referer&#34;
 HeaderRetryAfter           = &#34;Retry-After&#34;
 HeaderSecWebSocketKey1     = &#34;Sec-Websocket-Key1&#34;
 HeaderSecWebSocketKey2     = &#34;Sec-Websocket-Key2&#34;
 HeaderSecWebSocketProtocol = &#34;Sec-Websocket-Protocol&#34;
 HeaderServer               = &#34;Server&#34;
 HeaderSetCookie            = &#34;Set-Cookie&#34;
 HeaderTE                   = &#34;Te&#34;
 HeaderTrailer              = &#34;Trailer&#34;
 HeaderTransferEncoding     = &#34;Transfer-Encoding&#34;
 HeaderUpgrade              = &#34;Upgrade&#34;
 HeaderUserAgent            = &#34;User-Agent&#34;
 HeaderVary                 = &#34;Vary&#34;
 HeaderVia                  = &#34;Via&#34;
 HeaderWWWAuthenticate      = &#34;Www-Authenticate&#34;
 HeaderWarning              = &#34;Warning&#34;
 HeaderXXSRFToken           = &#34;X-Xsrftoken&#34;
)
</pre>
<p>
HTTP status codes from RFC 2606
</p>

<pre>
const (
 StatusContinue                     = 100
 StatusSwitchingProtocols           = 101
 StatusOK                           = 200
 StatusCreated                      = 201
 StatusAccepted                     = 202
 StatusNonAuthoritativeInformation  = 203
 StatusNoContent                    = 204
 StatusResetContent                 = 205
 StatusPartialContent               = 206
 StatusMultipleChoices              = 300
 StatusMovedPermanently             = 301
 StatusFound                        = 302
 StatusSeeOther                     = 303
 StatusNotModified                  = 304
 StatusUseProxy                     = 305
 StatusTemporaryRedirect            = 307
 StatusBadRequest                   = 400
 StatusUnauthorized                 = 401
 StatusPaymentRequired              = 402
 StatusForbidden                    = 403
 StatusNotFound                     = 404
 StatusMethodNotAllowed             = 405
 StatusNotAcceptable                = 406
 StatusProxyAuthenticationRequired  = 407
 StatusRequestTimeout               = 408
 StatusConflict                     = 409
 StatusGone                         = 410
 StatusLengthRequired               = 411
 StatusPreconditionFailed           = 412
 StatusRequestEntityTooLarge        = 413
 StatusRequestURITooLong            = 414
 StatusUnsupportedMediaType         = 415
 StatusRequestedRangeNotSatisfiable = 416
 StatusExpectationFailed            = 417
 StatusInternalServerError          = 500
 StatusNotImplemented               = 501
 StatusBadGateway                   = 502
 StatusServiceUnavailable           = 503
 StatusGatewayTimeout               = 504
 StatusHTTPVersionNotSupported      = 505
)
</pre>
<p>
Commonly used protocol versions in format returned by the ProtocolVersion
function.
</p>

<pre>
const (
 ProtocolVersion10 = 1000 // HTTP/1.0
 ProtocolVersion11 = 1001 // HTTP/1.1
)
</pre>
<p>
ContentTypeHTML is the content type for UTF-8 encoded HTML.
</p>

<pre>
const ContentTypeHTML = &#34;text/html; charset=\&#34;utf-8\&#34;&#34;
</pre>
<p>
TimeLayout is the time layout used for HTTP headers and other values.
</p>

<pre>
const TimeLayout = &#34;Mon, 02 Jan 2006 15:04:05 GMT&#34;
</pre>

<h2 id="variables">Variables</h2>

<pre>
var (
 ErrInvalidState          = os.NewError(&#34;object in invalid state&#34;)
 ErrBadFormat             = os.NewError(&#34;bad data format&#34;)
 ErrRequestEntityTooLarge = os.NewError(&#34;HTTP request entity too large&#34;)
)
</pre>

<pre>
var (
 ErrLineTooLong    = os.NewError(&#34;HTTP header line too long&#34;)
 ErrBadHeaderLine  = os.NewError(&#34;could not parse HTTP header line&#34;)
 ErrHeaderTooLong  = os.NewError(&#34;HTTP header value too long&#34;)
 ErrHeadersTooLong = os.NewError(&#34;too many HTTP headers&#34;)
)
</pre>

<h2 id="FilterRespond">func <a href="http://github.com/garyburd/twister/blob/master/web/middleware.go#L35">FilterRespond</a></h2>
<p><code>func FilterRespond(req *Request, filter func(status int, header HeaderMap) (int, HeaderMap))</code></p>
<p>
FilterRespond replaces the request&#39;s responder with one that filters the
arguments to Respond through the supplied filter. This function is intended
to be used by middleware.
</p>

<h2 id="FormatDeltaDays">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L41">FormatDeltaDays</a></h2>
<p><code>func FormatDeltaDays(delta int) string</code></p>
<p>
FormatDeltaDays returns current time plus delta formatted per HTTP conventions.
</p>

<h2 id="FormatDeltaSeconds">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L36">FormatDeltaSeconds</a></h2>
<p><code>func FormatDeltaSeconds(delta int) string</code></p>
<p>
FormatDeltaSeconds returns current time plus delta formatted per HTTP conventions.
</p>

<h2 id="HTMLEscapeString">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L376">HTMLEscapeString</a></h2>
<p><code>func HTMLEscapeString(s string) string</code></p>
<p>
HTMLEscapeString returns s with special HTML characters escaped.
</p>

<h2 id="HeaderName">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L401">HeaderName</a></h2>
<p><code>func HeaderName(name string) string</code></p>
<p>
HeaderName returns the canonical format of the header name.
</p>

<h2 id="HeaderNameBytes">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L407">HeaderNameBytes</a></h2>
<p><code>func HeaderNameBytes(p []byte) string</code></p>
<p>
HeaderNameBytes returns the canonical format for the header name specified
by the bytes in p. This function modifies the contents p.
</p>

<h2 id="ParseMultipartForm">func <a href="http://github.com/garyburd/twister/blob/master/web/multipart.go#L39">ParseMultipartForm</a></h2>
<p><code>func ParseMultipartForm(req *Request, maxRequestBodyLen int) ([]Part, os.Error)</code></p>
<p>
ParseMultipartForm parses a multipart/form-data body. Form fields are
added to the request Param. This function loads the entire request body in
memory. This may not be appropriate in some scenarios.
</p>

<h2 id="ProtocolVersion">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L149">ProtocolVersion</a></h2>
<p><code>func ProtocolVersion(major int, minor int) int</code></p>
<p>
ProtocolVersion combines HTTP major and minor protocol numbers into a single
integer for easy comparision of protocol versions.
</p>

<h2 id="QuoteHeaderValue">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L425">QuoteHeaderValue</a></h2>
<p><code>func QuoteHeaderValue(s string) string</code></p>
<p>
QuoteHeaderValue quotes s using quoted-string rules described in RFC 2616.
</p>

<h2 id="QuoteHeaderValueOrToken">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L441">QuoteHeaderValueOrToken</a></h2>
<p><code>func QuoteHeaderValueOrToken(s string) string</code></p>
<p>
QuoteHeaderValueOrToken quotes s if s is not a valid token per RFC 2616.
</p>

<h2 id="RunHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/test.go#L104">RunHandler</a></h2>
<p><code>func RunHandler(url string, method string, reqHeader HeaderMap, reqBody []byte, handler Handler) (status int, header HeaderMap, respBody []byte)</code></p>
<p>
RunHandler runs the handler with a request created from the arguments and
returns the response. This function is intended to be used in tests.
</p>

<h2 id="SignValue">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L241">SignValue</a></h2>
<p><code>func SignValue(secret, context string, maxAgeSeconds int, value string) string</code></p>
<p>
SignValue returns a string containing value, an expiration time and a
signature. The expiration time is computed from the current time and
maxAgeSeconds.  The signature is an HMAC SHA-1 signature of value, context
and the expiration time. Use the function VerifyValue to extract the value,
check the expiration time and verify the signature.
</p>
<p>
SignValue can be used to store credentials in a cookie:
</p>
<pre>var secret string // Initialized by application
const uidCookieMaxAge = 3600 * 24 * 30

// uidCookieValue returns the Set-Cookie header value containing a
// signed and timestamped user id.
func uidCookieValue(uid string) string {
    s := web.SignValue(secret, &#34;uid&#34;, uidCookieMaxAge, uid)
    return web.NewCookie(&#34;uid&#34;, s).MaxAge(uidCookieMaxAge).String()
}

// requestUid returns the user id from the request cookie. An error
// is returned if the cookie is missing, the value has expired or the
// signature is not valid.
func requestUid(req *web.Request) (string, os.Error) {
    return web.VerifyValue(secret, &#34;uid&#34;, req.Cookie.Get(&#34;uid&#34;))
}
</pre>

<h2 id="StatusText">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L139">StatusText</a></h2>
<p><code>func StatusText(status int) string</code></p>
<p>
StatusText returns a text description of an HTTP status code.
</p>

<h2 id="UnquoteHeaderValue">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L452">UnquoteHeaderValue</a></h2>
<p><code>func UnquoteHeaderValue(s string) string</code></p>
<p>
UnquoteHeaderValue unquotes s if s is surrounded by quotes, otherwise s is
returned.
</p>

<h2 id="VerifyValue">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L251">VerifyValue</a></h2>
<p><code>func VerifyValue(secret, context string, signedValue string) (string, os.Error)</code></p>
<p>
VerifyValue extracts a value from a string created by SignValue. An error is
returned if the expiration time has elapsed or the signature is not correct.
</p>


<h2 id="Cookie">type Cookie</h2>
<p>
Cookie is a helper for constructing Set-Cookie header values.
</p>
<p>
Cookie supports the ancient Netscape draft specification for cookies
(<a href="http://goo.gl/1WSx3">http://goo.gl/1WSx3</a>) and the modern HttpOnly attribute
(<a href="http://www.owasp.org/index.php/HttpOnly">http://www.owasp.org/index.php/HttpOnly</a>). Cookie does not attempt to
support any RFC for cookies because the RFCs are not supported by popular
browsers.
</p>
<p>
As a convenience, the NewCookie function returns a cookie with the path
attribute set to &#34;/&#34; and the httponly attribute set to true.
</p>
<p>
The following example shows how to set a cookie header using Cookie:
</p>
<pre>func myHandler(req *web.Request) {
    c := web.NewCookie(&#34;my-cookie-name&#34;, &#34;my-cookie-value&#34;).String()
    w := req.Respond(web.StatusOK, web.HeaderSetCookie, c)
    io.WriteString(w, &#34;&lt;html&gt;&lt;body&gt;Hello&lt;/body&gt;&lt;/html&gt;&#34;)
}
</pre>

<pre>type Cookie struct {
 // contains unexported fields
}</pre>



    <h3 id="NewCookie">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L306">NewCookie</a></h3>
    <p><code>func NewCookie(name, value string) *Cookie</code></p>
    <p>
NewCookie returns a new cookie with the given name and value, the path
attribute set to &#34;/&#34; and the httponly attribute set to true.
</p>


    <h3 id="Cookie.Delete">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L329">Delete</a></h3>
    <p><code>func (c *Cookie) Delete() *Cookie</code></p>
    <p>
Delete sets the expiration date to a time in the past.
</p>

    <h3 id="Cookie.Domain">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L317">Domain</a></h3>
    <p><code>func (c *Cookie) Domain(domain string) *Cookie</code></p>
    <p>
Domain sets the cookie domain attribute. If the host is &#34;&#34;, then the domain
attribute is not included in the header value.
</p>

    <h3 id="Cookie.HTTPOnly">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L336">HTTPOnly</a></h3>
    <p><code>func (c *Cookie) HTTPOnly(httpOnly bool) *Cookie</code></p>
    <p>
HTTPOnly sets the httponly attribute. The NewCookie function
initializes the httponly attribute to true.
</p>

    <h3 id="Cookie.MaxAge">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L323">MaxAge</a></h3>
    <p><code>func (c *Cookie) MaxAge(seconds int) *Cookie</code></p>
    <p>
MaxAge specifies the maximum age for a cookie. The age is converted to an
absolute expiration time when the header value is rendered. If the maximum
age is 0, then the expiration time is not included in the header value
and the browser will handle the cookie as a &#34;session&#34; cookie.
</p>

    <h3 id="Cookie.MaxAgeDays">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L326">MaxAgeDays</a></h3>
    <p><code>func (c *Cookie) MaxAgeDays(days int) *Cookie</code></p>
    <p>
MaxAgeDays sets the maximum age for the cookie in days.
</p>

    <h3 id="Cookie.Path">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L313">Path</a></h3>
    <p><code>func (c *Cookie) Path(path string) *Cookie</code></p>
    <p>
Path sets the cookie path attribute. The path must either be &#34;&#34; or start with a
&#39;/&#39;.  The NewCookie function initializes the path to &#34;/&#34;. If the path is &#34;&#34;,
then the path attribute is not included in the header value.
</p>

    <h3 id="Cookie.Secure">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L332">Secure</a></h3>
    <p><code>func (c *Cookie) Secure(secure bool) *Cookie</code></p>
    <p>
Secure sets the secure attribute.
</p>

    <h3 id="Cookie.String">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L342">String</a></h3>
    <p><code>func (c *Cookie) String() string</code></p>
    <p>
String renders the Set-Cookie header value as a string.
</p>


<h2 id="ErrorHandler">type ErrorHandler</h2>
<p>
ErrorHandler handles request errors.
</p>

<pre>type ErrorHandler func(req *Request, status int, reason os.Error, header HeaderMap)</pre>





<h2 id="Handler">type Handler</h2>
<p>
Handler is the interface for web handlers.
</p>

<pre>type Handler interface {
 ServeWeb(req *Request)
}</pre>



    <h3 id="DirectoryHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/handlers.go#L83">DirectoryHandler</a></h3>
    <p><code>func DirectoryHandler(root string, extraHeader ...string) Handler</code></p>
    <p>
DirectoryHandler returns a request handler that serves static files from root
using using the relative request parameter &#34;path&#34;. The &#34;path&#34; parameter is
typically set using a Router pattern match:
</p>
<pre>r.Register(&#34;/static/&lt;path:.*&gt;&#34;, &#34;GET&#34;, DirectoryHandler(root))
</pre>
<p>
If the &#34;v&#34; request parameter is supplied, then the cache control headers are
set to expire the file in 10 years.
</p>

    <h3 id="FileHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/handlers.go#L128">FileHandler</a></h3>
    <p><code>func FileHandler(fname string, extraHeader ...string) Handler</code></p>
    <p>
FileHandler returns a request handler that serves a static file specified by
fname.
</p>
<p>
If the &#34;v&#34; request parameter is supplied, then the cache control headers are
set to expire the file in 10 years.
</p>

    <h3 id="FormHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/middleware.go#L134">FormHandler</a></h3>
    <p><code>func FormHandler(maxRequestBodyLen int, checkXSRF bool, h Handler) Handler</code></p>
    <p>
FormHandler returns a handler that parses form encoded request bodies.
</p>
<p>
If the request body is larger than maxRequestBodyLen, then the handler
responds with an error instead of parsing the request body.
</p>
<p>
If xsrfCheck is true, then cross-site request forgery protection is enabled.
The handler rejects POST, PUT, and DELETE requests if the handler does not
find a matching value for the &#34;xsrf&#34; cookie in the &#34;xsrf&#34; request parameter
or the X-XSRFToken header.
</p>
<p>
The handler ensures that the &#34;xsrf&#34; cookie and the &#34;xsrf&#34; request parameter
are set before passing the the request to the downstream handler or the
error handler. The application must include the value fo the &#34;xsrf&#34; request
parameter in POSTed forms or pass the value to AJAX code so that the
X-XSRFToken header can be set.
</p>
<p>
See <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">http://en.wikipedia.org/wiki/Cross-site_request_forgery</a> for information
on cross-site request forgery.
</p>

    <h3 id="NotFoundHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/handlers.go#L163">NotFoundHandler</a></h3>
    <p><code>func NotFoundHandler() Handler</code></p>
    <p>
NotFoundHandler returns a request handler that responds with 404 not found.
</p>

    <h3 id="ProcessForm">func <a href="http://github.com/garyburd/twister/blob/master/web/middleware.go#L112">ProcessForm</a></h3>
    <p><code>func ProcessForm(maxRequestBodyLen int, checkXSRF bool, handler Handler) Handler</code></p>
    <p>
PorcessForm is deprecated. Use FormHandler.
</p>

    <h3 id="ProxyHeaderHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/middleware.go#L86">ProxyHeaderHandler</a></h3>
    <p><code>func ProxyHeaderHandler(addrName, schemeName string, h Handler) Handler</code></p>
    <p>
ProxyHeaderHandler returns a handler that overrides the Request.RemoteAddr field
with the value of the header specified by addrName and the
Request.URL.Scheme field with the value of the header specified by
schemeName. No fix up is done for a field if the header name equals &#34;&#34; or the
header is not present.
</p>
<p>
The header names must be in canonical header name format.
</p>
<p>
Here&#39;s an example of how to use this handler with Nginx. In the nginx proxy
configuration, specify a header for the IP address and scheme. The host
header should also be passed through the proxy:
</p>
<pre>location / {
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Scheme $scheme;
    proxy_set_header Host $http_host;
    proxy_pass <a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a>;
}
</pre>
<p>
In the main function for the application, wrap the application handler with
the proxy fix up:
</p>
<pre> import (
     &#34;github.com/garyburd/twister/web&#34;
     &#34;github.com/garyburd/twister/server&#34;
 )

 func main() {
     var h web.Handler
     ... setup the application handler
     h = web.ProxyHeaderHandler(&#34;X-Scheme&#34;, &#34;X-Real-Ip&#34;, h)
	    server.Run(&#34;:8080&#34;, h)
 }
</pre>

    <h3 id="RedirectHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/handlers.go#L156">RedirectHandler</a></h3>
    <p><code>func RedirectHandler(url string, permanent bool) Handler</code></p>
    <p>
RedirectHandler returns a request handler that redirects to the given URL.
</p>

    <h3 id="SetErrorHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/middleware.go#L40">SetErrorHandler</a></h3>
    <p><code>func SetErrorHandler(e ErrorHandler, h Handler) Handler</code></p>
    <p>
SetErrorHandler returns a handler that sets the request&#39;s error handler e.
</p>



<h2 id="HandlerFunc">type HandlerFunc</h2>
<p>
HandlerFunc is a type adapter to allow the use of ordinary functions as web
handlers. If the function returns an error, then the adapter responds to the
request with an error response.
</p>

<pre>type HandlerFunc func(*Request)</pre>




    <h3 id="HandlerFunc.ServeWeb">func (HandlerFunc) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L124">ServeWeb</a></h3>
    <p><code>func (f HandlerFunc) ServeWeb(req *Request)</code></p>
    <p>
ServeWeb calls f(req).
</p>


<h2 id="HeaderMap">type HeaderMap</h2>
<p>
HeaderMap maps header names to a slice of header values.
</p>
<p>
The header names must be in canonical format: the first letter and letters
following &#39;-&#39; are uppercase and all other letters are lowercase.  The
Header* constants are in canonical format. Use the function HeaderName to
convert a string to canonical format.
</p>

<pre>type HeaderMap map[string][]string</pre>



    <h3 id="NewHeaderMap">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L74">NewHeaderMap</a></h3>
    <p><code>func NewHeaderMap(kvs ...string) HeaderMap</code></p>
    <p>
NewHeaderMap returns a map initialized with the given key-value pairs.
</p>


    <h3 id="HeaderMap.Add">func (HeaderMap) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L86">Add</a></h3>
    <p><code>func (m HeaderMap) Add(key string, value string)</code></p>
    <p>
Add appends value to slice for given key.
</p>

    <h3 id="HeaderMap.Get">func (HeaderMap) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L96">Get</a></h3>
    <p><code>func (m HeaderMap) Get(key string) string</code></p>
    <p>
Get returns the first value for given key or &#34;&#34; if the key is not found.
</p>

    <h3 id="HeaderMap.GetList">func (HeaderMap) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L116">GetList</a></h3>
    <p><code>func (m HeaderMap) GetList(key string) []string</code></p>
    <p>
GetList returns list of comma separated values over multiple header values
for the given key. Commas are ignored in quoted strings. Quoted values are
not unescaped or unquoted. Whitespace is trimmmed.
</p>

    <h3 id="HeaderMap.GetValueParam">func (HeaderMap) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L108">GetValueParam</a></h3>
    <p><code>func (m HeaderMap) GetValueParam(key string) (value string, param map[string]string)</code></p>
    <p>
GetValueParam returns a value and optional semi-colon prefixed name-value
pairs for header with name key. The value and parameter keys are converted
to lowercase. All whitespace is trimmed. This format is used by the
Content-Type and Content-Disposition headers.
</p>

    <h3 id="HeaderMap.ParseHttpHeader">func (HeaderMap) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L195">ParseHttpHeader</a></h3>
    <p><code>func (m HeaderMap) ParseHttpHeader(br *bufio.Reader) (err os.Error)</code></p>
    <p>
ParseHttpHeader parses the HTTP headers and appends the values to the
supplied map. Header names are converted to canonical format.
</p>

    <h3 id="HeaderMap.ParseHttpHeaderBytes">func (HeaderMap) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L205">ParseHttpHeaderBytes</a></h3>
    <p><code>func (m HeaderMap) ParseHttpHeaderBytes(p []byte) (int, os.Error)</code></p>
    <p>
ParseHttpHeaderBytes parses the HTTP headers and appends the values to the
supplied map. Header names are converted to canonical format. The function
returns the number of bytes in the header including the trailing blank line
and its line terminator.
</p>

    <h3 id="HeaderMap.Set">func (HeaderMap) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L91">Set</a></h3>
    <p><code>func (m HeaderMap) Set(key string, value string)</code></p>
    <p>
Set value for given key, discarding previous values if any.
</p>

    <h3 id="HeaderMap.WriteHttpHeader">func (HeaderMap) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L163">WriteHttpHeader</a></h3>
    <p><code>func (m HeaderMap) WriteHttpHeader(w io.Writer) os.Error</code></p>
    <p>
WriteHttpHeader writes the map in HTTP header format.
</p>


<h2 id="HostRouter">type HostRouter</h2>
<p>
HostRouter dispatches HTTP requests to a handler using the host HTTP header.
</p>
<p>
A host router maintains a list of routes where each route is a (pattern,
handler) pair.  The router dispatches requests by matching the host header
against the patterns in the order that the routes were registered. If a
matching route is found, the request is dispatched to the route&#39;s handler.
</p>
<p>
A pattern is a string with embedded parameters. A parameter has the syntax:
</p>
<pre>&#39;&lt;&#39; name (&#39;:&#39; regexp)? &#39;&gt;&#39;
</pre>
<p>
If the regexp is not specified, then the regexp is set to to [^.]+.  The
host router adds the parameters to the request Param.
</p>
<p>
To facilitate debugging on localhost, the router overrides the request host
with the value of the hostOverride flag if set.
</p>

<pre>type HostRouter struct {
 // contains unexported fields
}</pre>



    <h3 id="NewHostRouter">func <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L230">NewHostRouter</a></h3>
    <p><code>func NewHostRouter(defaultHandler Handler) *HostRouter</code></p>
    <p>
NewHostRouter allocates and initializes a new HostRouter.
</p>


    <h3 id="HostRouter.Register">func (*HostRouter) <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L238">Register</a></h3>
    <p><code>func (router *HostRouter) Register(hostPattern string, handler Handler) *HostRouter</code></p>
    <p>
Register a handler for the given pattern.
</p>

    <h3 id="HostRouter.ServeWeb">func (*HostRouter) <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L259">ServeWeb</a></h3>
    <p><code>func (router *HostRouter) ServeWeb(req *Request)</code></p>
    <p>
ServeWeb dispatches the request to a registered handler.
</p>


<h2 id="ParamMap">type ParamMap</h2>
<p>
ParamMap maps parameter names to slices of paramete values.
</p>

<pre>type ParamMap map[string][]string</pre>



    <h3 id="NewParamMap">func <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L27">NewParamMap</a></h3>
    <p><code>func NewParamMap(kvs ...string) ParamMap</code></p>
    <p>
NewParamMap returns a map initialized with the given key-value pairs.
</p>


    <h3 id="ParamMap.Add">func (ParamMap) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L48">Add</a></h3>
    <p><code>func (m ParamMap) Add(key string, value string)</code></p>
    <p>
Add appends value to slice for given key.
</p>

    <h3 id="ParamMap.FormEncodedBytes">func (ParamMap) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L69">FormEncodedBytes</a></h3>
    <p><code>func (m ParamMap) FormEncodedBytes() []byte</code></p>
    <p>
FormEncodedBytes returns a buffer containing the URL form encoding of the
map.
</p>

    <h3 id="ParamMap.FormEncodedString">func (ParamMap) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L90">FormEncodedString</a></h3>
    <p><code>func (m ParamMap) FormEncodedString() string</code></p>
    <p>
FormEncodedString returns a string containing the URL form encoding of the
map.
</p>

    <h3 id="ParamMap.Get">func (ParamMap) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L39">Get</a></h3>
    <p><code>func (m ParamMap) Get(key string) string</code></p>
    <p>
Get returns the first value for given key or &#34;&#34; if the key is not found.
</p>

    <h3 id="ParamMap.ParseFormEncodedBytes">func (ParamMap) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L110">ParseFormEncodedBytes</a></h3>
    <p><code>func (m ParamMap) ParseFormEncodedBytes(p []byte) os.Error</code></p>
    <p>
ParseFormEncodedBytes parses the URL-encoded form and appends the values to
the supplied map. This function modifies the contents of p.
</p>

    <h3 id="ParamMap.Set">func (ParamMap) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L53">Set</a></h3>
    <p><code>func (m ParamMap) Set(key string, value string)</code></p>
    <p>
Set value for given key, discarding previous values if any.
</p>

    <h3 id="ParamMap.StringMap">func (ParamMap) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L59">StringMap</a></h3>
    <p><code>func (m ParamMap) StringMap() map[string]string</code></p>
    <p>
StringMap returns a string to string map by discarding all but the first
value for a key.
</p>


<h2 id="Part">type Part</h2>
<p>
Part represents an element of a multi-part request entity.
</p>

<pre>type Part struct {
 Name         string
 Filename     string
 ContentType  string
 ContentParam map[string]string
 Data         []byte
}</pre>





<h2 id="Request">type Request</h2>
<p>
Request represents an HTTP request to the server.
</p>

<pre>type Request struct {
 Responder Responder // The response.


 // Uppercase request method. GET, POST, etc.
 Method string

 // The request URL with host and scheme set appropriately.
 URL *http.URL

 // Protocol version: major version * 1000 + minor version	
 ProtocolVersion int

 // The IP address of the client sending the request to the server.
 RemoteAddr string

 // Header maps canonical header names to slices of header values.
 Header HeaderMap

 // Request params from the query string, post body, routers and other.
 Param ParamMap

 // Cookies.
 Cookie ParamMap

 // Lowercase content type, not including params.
 ContentType string

 // Parameters from Content-Type header
 ContentParam map[string]string

 // ErrorHandler responds to the request with the given status code.
 // Applications can set the error handler using middleware. 
 ErrorHandler ErrorHandler

 // ContentLength is the length of the request body or -1 if the content
 // length is not known.
 ContentLength int

 // The request body.
 Body RequestBody

 // Attributes attached to the request by middleware. 
 Attribute map[string]interface{}
 // contains unexported fields
}</pre>



    <h3 id="NewRequest">func <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L128">NewRequest</a></h3>
    <p><code>func NewRequest(remoteAddr string, method string, url *http.URL, protocolVersion int, header HeaderMap) (req *Request, err os.Error)</code></p>
    <p>
NewRequest allocates and initializes a request. This function is provided
for the convenience of protocol adapters (fcgi, native http server, ...).
</p>


    <h3 id="Request.BodyBytes">func (*Request) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L208">BodyBytes</a></h3>
    <p><code>func (req *Request) BodyBytes(maxLen int) ([]byte, os.Error)</code></p>
    <p>
BodyBytes returns the request body a slice of bytes. If maxLen is negative,
then no limit is imposed on the length of the body. If the body is longer
than maxLen, then ErrRequestEntityTooLarge is returned.
</p>

    <h3 id="Request.Error">func (*Request) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L182">Error</a></h3>
    <p><code>func (req *Request) Error(status int, reason os.Error, headerKeysAndValues ...string)</code></p>
    <p>
Error responds to the request with an error.
</p>

    <h3 id="Request.ParseForm">func (*Request) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L236">ParseForm</a></h3>
    <p><code>func (req *Request) ParseForm(maxRequestBodyLen int) os.Error</code></p>
    <p>
ParseForm parses url-encoded form bodies. ParseForm is idempotent.  Most
applications should use the ParseForm middleware instead of calling this
method directly.
</p>

    <h3 id="Request.Redirect">func (*Request) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L187">Redirect</a></h3>
    <p><code>func (req *Request) Redirect(url string, perm bool, headerKeysAndValues ...string)</code></p>
    <p>
Redirect responds to the request with a redirect to the specified URL.
</p>

    <h3 id="Request.Respond">func (*Request) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L168">Respond</a></h3>
    <p><code>func (req *Request) Respond(status int, headerKeysAndValues ...string) ResponseBody</code></p>
    <p>
Respond is a convenience function that adds (key, value) pairs in
headerKeysAndValues to a HeaderMap and calls through to the connection&#39;s
Respond method.
</p>


<h2 id="RequestBody">type RequestBody</h2>
<p>
RequestBody represents the request body.
</p>

<pre>type RequestBody interface {
 io.Reader
}</pre>





<h2 id="Responder">type Responder</h2>
<p>
Responder represents the response.
</p>

<pre>type Responder interface {
 // Respond commits the status and headers to the network and returns
 // a writer for the response body.
 Respond(status int, header HeaderMap) ResponseBody

 // Hijack lets the caller take over the connection from the HTTP server.
 // The caller is responsible for closing the connection. Returns connection
 // and bytes buffered by the server.
 Hijack() (conn net.Conn, buf []byte, err os.Error)
}</pre>





<h2 id="ResponseBody">type ResponseBody</h2>
<p>
ResponseBody represents the response body.
</p>

<pre>type ResponseBody interface {
 io.Writer
 // Flush writes any buffered data to the network.
 Flush() os.Error
}</pre>





<h2 id="Router">type Router</h2>
<p>
Router dispatches HTTP requests to a handler using the path component of the
request URL and the request method.
</p>
<p>
A router maintains a list of routes. A route consists of a request path
pattern and a collection of (method, handler) pairs.
</p>
<p>
A pattern is a string with embedded parameters. A parameter has the syntax:
</p>
<pre>&#39;&lt;&#39; name (&#39;:&#39; regexp)? &#39;&gt;&#39;
</pre>
<p>
If the regexp is not specified, then the regexp is set to to [^/]+.
</p>
<p>
The pattern must begin with the character &#39;/&#39;.
</p>
<p>
A router dispatches requests by matching the path component of the request
URL against the route patterns in the order that the routes were registered.
If a matching route is found, then the router searches the route for a
handler using the request method, &#34;GET&#34; if the request method is &#34;HEAD&#34; and
&#34;*&#34;. If a handler is not found, the router responds with HTTP status 405. If
a route is not found, then the router responds with HTTP status 404.
</p>
<p>
The handler can access the path parameters in the request Param.
</p>
<p>
If a pattern ends with &#39;/&#39;, then the router redirects the URL without the
trailing slash to the URL with the trailing slash.
</p>

<pre>type Router struct {
 // contains unexported fields
}</pre>



    <h3 id="NewRouter">func <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L198">NewRouter</a></h3>
    <p><code>func NewRouter() *Router</code></p>
    <p>
NewRouter allocates and initializes a new Router.
</p>


    <h3 id="Router.Register">func (*Router) <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L108">Register</a></h3>
    <p><code>func (router *Router) Register(pattern string, handlers ...interface{}) *Router</code></p>
    <p>
Register the route with the given pattern and handlers. The structure of the
handlers argument is:
</p>
<p>
(method handler)+
</p>
<p>
where method is a string and handler is a Handler or a
func(*Request). Use &#34;*&#34; to match all methods.
</p>

    <h3 id="Router.ServeWeb">func (*Router) <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L189">ServeWeb</a></h3>
    <p><code>func (router *Router) ServeWeb(req *Request)</code></p>
    <p>
ServeWeb dispatches the request to a registered handler.
</p>


<hr>
This page was generated automatically from the source code. If you installed
Twister using <a href="http://golang.org/cmd/goinstall/">goinstall</a>, then
you can also view the source documentation with <a
href="http://golang.org/cmd/godoc/">godoc</a>.  
</div>
</body>
</html>
