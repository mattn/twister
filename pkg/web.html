<!DOCTYPE html>
<html>
<head>
<title>Twister: web</title>
<link rel="stylesheet" href="../static/base.css" type="text/css"/> 
</head>
<body>
<div id="content"> 
<h1><a href="..">Twister</a>: web</h1>

<h4>Table Of Contents</h4>
<ul>
<li><a href="#package">Package</a>
<li><a href="#constants">Constants</a>
<li><a href="#variables">Variables</a>
<li><a href="#CheckXSRF">func CheckXSRF</a>
<li><a href="#FilterRespond">func FilterRespond</a>
<li><a href="#FormatDeltaDays">func FormatDeltaDays</a>
<li><a href="#FormatDeltaSeconds">func FormatDeltaSeconds</a>
<li><a href="#HTMLEscapeString">func HTMLEscapeString</a>
<li><a href="#HeaderName">func HeaderName</a>
<li><a href="#HeaderNameBytes">func HeaderNameBytes</a>
<li><a href="#ParseMultipartForm">func ParseMultipartForm</a>
<li><a href="#ProtocolVersion">func ProtocolVersion</a>
<li><a href="#QuoteHeaderValue">func QuoteHeaderValue</a>
<li><a href="#QuoteHeaderValueOrToken">func QuoteHeaderValueOrToken</a>
<li><a href="#RunHandler">func RunHandler</a>
<li><a href="#ServeFile">func ServeFile</a>
<li><a href="#SignValue">func SignValue</a>
<li><a href="#StatusText">func StatusText</a>
<li><a href="#UnquoteHeaderValue">func UnquoteHeaderValue</a>
<li><a href="#VerifyValue">func VerifyValue</a>
<li><a href="#Cookie">type Cookie</a>
        <ul>
    <li><a href="#NewCookie">func NewCookie</a>
    <li><a href="#Cookie.Delete">func (*Cookie) Delete</a>
    <li><a href="#Cookie.Domain">func (*Cookie) Domain</a>
    <li><a href="#Cookie.HTTPOnly">func (*Cookie) HTTPOnly</a>
    <li><a href="#Cookie.MaxAge">func (*Cookie) MaxAge</a>
    <li><a href="#Cookie.MaxAgeDays">func (*Cookie) MaxAgeDays</a>
    <li><a href="#Cookie.Path">func (*Cookie) Path</a>
    <li><a href="#Cookie.Secure">func (*Cookie) Secure</a>
    <li><a href="#Cookie.String">func (*Cookie) String</a>
        </ul>
<li><a href="#ErrorHandler">type ErrorHandler</a>
<li><a href="#Flusher">type Flusher</a>
<li><a href="#Handler">type Handler</a>
        <ul>
    <li><a href="#DirectoryHandler">func DirectoryHandler</a>
    <li><a href="#FileHandler">func FileHandler</a>
    <li><a href="#FormHandler">func FormHandler</a>
    <li><a href="#NotFoundHandler">func NotFoundHandler</a>
    <li><a href="#ProxyHeaderHandler">func ProxyHeaderHandler</a>
    <li><a href="#RedirectHandler">func RedirectHandler</a>
    <li><a href="#SetErrorHandler">func SetErrorHandler</a>
        </ul>
<li><a href="#HandlerFunc">type HandlerFunc</a>
            <ul>
    <li><a href="#HandlerFunc.ServeWeb">func (HandlerFunc) ServeWeb</a>
            </ul>
<li><a href="#Header">type Header</a>
        <ul>
    <li><a href="#NewHeader">func NewHeader</a>
    <li><a href="#Header.Add">func (Header) Add</a>
    <li><a href="#Header.Get">func (Header) Get</a>
    <li><a href="#Header.GetAccept">func (Header) GetAccept</a>
    <li><a href="#Header.GetList">func (Header) GetList</a>
    <li><a href="#Header.GetValueParam">func (Header) GetValueParam</a>
    <li><a href="#Header.ParseHttpHeader">func (Header) ParseHttpHeader</a>
    <li><a href="#Header.Set">func (Header) Set</a>
    <li><a href="#Header.WriteHttpHeader">func (Header) WriteHttpHeader</a>
        </ul>
<li><a href="#HostRouter">type HostRouter</a>
        <ul>
    <li><a href="#NewHostRouter">func NewHostRouter</a>
    <li><a href="#HostRouter.Register">func (*HostRouter) Register</a>
    <li><a href="#HostRouter.ServeWeb">func (*HostRouter) ServeWeb</a>
        </ul>
<li><a href="#MultipartReader">type MultipartReader</a>
        <ul>
    <li><a href="#NewMultipartReader">func NewMultipartReader</a>
    <li><a href="#MultipartReader.Next">func (*MultipartReader) Next</a>
        </ul>
<li><a href="#Part">type Part</a>
<li><a href="#Request">type Request</a>
        <ul>
    <li><a href="#NewRequest">func NewRequest</a>
    <li><a href="#Request.BodyBytes">func (*Request) BodyBytes</a>
    <li><a href="#Request.Error">func (*Request) Error</a>
    <li><a href="#Request.ParseForm">func (*Request) ParseForm</a>
    <li><a href="#Request.Redirect">func (*Request) Redirect</a>
    <li><a href="#Request.Respond">func (*Request) Respond</a>
        </ul>
<li><a href="#Responder">type Responder</a>
<li><a href="#Router">type Router</a>
        <ul>
    <li><a href="#NewRouter">func NewRouter</a>
    <li><a href="#Router.Register">func (*Router) Register</a>
    <li><a href="#Router.ServeWeb">func (*Router) ServeWeb</a>
        </ul>
<li><a href="#ServeFileOptions">type ServeFileOptions</a>
<li><a href="#ValueParams">type ValueParams</a>
<li><a href="#Values">type Values</a>
        <ul>
    <li><a href="#NewValues">func NewValues</a>
    <li><a href="#Values.Add">func (Values) Add</a>
    <li><a href="#Values.FormEncodedBytes">func (Values) FormEncodedBytes</a>
    <li><a href="#Values.FormEncodedString">func (Values) FormEncodedString</a>
    <li><a href="#Values.Get">func (Values) Get</a>
    <li><a href="#Values.ParseFormEncodedBytes">func (Values) ParseFormEncodedBytes</a>
    <li><a href="#Values.Set">func (Values) Set</a>
    <li><a href="#Values.StringMap">func (Values) StringMap</a>
        </ul>
</ul>

<h2 id="package">Package</h2>

<p><code>import "github.com/garyburd/twister/web"</code></p>

<p>
The web package defines the application programming interface to a web
server and implements functionality common to many web applications.
</p>


<h2 id="constants">Constants</h2>
<p>
Name of XSRF cookie and request parameter.
</p>

<pre>
const (
 XSRFCookieName = &#34;xsrf&#34;
 XSRFParamName  = &#34;xsrf&#34;
)
</pre>
<p>
Header names in canonical format.
</p>

<pre>
const (
 HeaderAccept               = &#34;Accept&#34;
 HeaderAcceptCharset        = &#34;Accept-Charset&#34;
 HeaderAcceptEncoding       = &#34;Accept-Encoding&#34;
 HeaderAcceptLanguage       = &#34;Accept-Language&#34;
 HeaderAcceptRanges         = &#34;Accept-Ranges&#34;
 HeaderAge                  = &#34;Age&#34;
 HeaderAllow                = &#34;Allow&#34;
 HeaderAuthorization        = &#34;Authorization&#34;
 HeaderCacheControl         = &#34;Cache-Control&#34;
 HeaderConnection           = &#34;Connection&#34;
 HeaderContentDisposition   = &#34;Content-Disposition&#34;
 HeaderContentEncoding      = &#34;Content-Encoding&#34;
 HeaderContentLanguage      = &#34;Content-Language&#34;
 HeaderContentLength        = &#34;Content-Length&#34;
 HeaderContentLocation      = &#34;Content-Location&#34;
 HeaderContentMD5           = &#34;Content-Md5&#34;
 HeaderContentRange         = &#34;Content-Range&#34;
 HeaderContentType          = &#34;Content-Type&#34;
 HeaderCookie               = &#34;Cookie&#34;
 HeaderDate                 = &#34;Date&#34;
 HeaderETag                 = &#34;Etag&#34;
 HeaderEtag                 = &#34;Etag&#34;
 HeaderExpect               = &#34;Expect&#34;
 HeaderExpires              = &#34;Expires&#34;
 HeaderFrom                 = &#34;From&#34;
 HeaderHost                 = &#34;Host&#34;
 HeaderIfMatch              = &#34;If-Match&#34;
 HeaderIfModifiedSince      = &#34;If-Modified-Since&#34;
 HeaderIfNoneMatch          = &#34;If-None-Match&#34;
 HeaderIfRange              = &#34;If-Range&#34;
 HeaderIfUnmodifiedSince    = &#34;If-Unmodified-Since&#34;
 HeaderLastModified         = &#34;Last-Modified&#34;
 HeaderLocation             = &#34;Location&#34;
 HeaderMaxForwards          = &#34;Max-Forwards&#34;
 HeaderOrigin               = &#34;Origin&#34;
 HeaderPragma               = &#34;Pragma&#34;
 HeaderProxyAuthenticate    = &#34;Proxy-Authenticate&#34;
 HeaderProxyAuthorization   = &#34;Proxy-Authorization&#34;
 HeaderRange                = &#34;Range&#34;
 HeaderReferer              = &#34;Referer&#34;
 HeaderRetryAfter           = &#34;Retry-After&#34;
 HeaderSecWebSocketKey1     = &#34;Sec-Websocket-Key1&#34;
 HeaderSecWebSocketKey2     = &#34;Sec-Websocket-Key2&#34;
 HeaderSecWebSocketProtocol = &#34;Sec-Websocket-Protocol&#34;
 HeaderServer               = &#34;Server&#34;
 HeaderSetCookie            = &#34;Set-Cookie&#34;
 HeaderTE                   = &#34;Te&#34;
 HeaderTrailer              = &#34;Trailer&#34;
 HeaderTransferEncoding     = &#34;Transfer-Encoding&#34;
 HeaderUpgrade              = &#34;Upgrade&#34;
 HeaderUserAgent            = &#34;User-Agent&#34;
 HeaderVary                 = &#34;Vary&#34;
 HeaderVia                  = &#34;Via&#34;
 HeaderWWWAuthenticate      = &#34;Www-Authenticate&#34;
 HeaderWarning              = &#34;Warning&#34;
 HeaderXXSRFToken           = &#34;X-Xsrftoken&#34;
)
</pre>
<p>
HTTP status codes from RFC 2606
</p>

<pre>
const (
 StatusContinue                     = 100
 StatusSwitchingProtocols           = 101
 StatusOK                           = 200
 StatusCreated                      = 201
 StatusAccepted                     = 202
 StatusNonAuthoritativeInformation  = 203
 StatusNoContent                    = 204
 StatusResetContent                 = 205
 StatusPartialContent               = 206
 StatusMultipleChoices              = 300
 StatusMovedPermanently             = 301
 StatusFound                        = 302
 StatusSeeOther                     = 303
 StatusNotModified                  = 304
 StatusUseProxy                     = 305
 StatusTemporaryRedirect            = 307
 StatusBadRequest                   = 400
 StatusUnauthorized                 = 401
 StatusPaymentRequired              = 402
 StatusForbidden                    = 403
 StatusNotFound                     = 404
 StatusMethodNotAllowed             = 405
 StatusNotAcceptable                = 406
 StatusProxyAuthenticationRequired  = 407
 StatusRequestTimeout               = 408
 StatusConflict                     = 409
 StatusGone                         = 410
 StatusLengthRequired               = 411
 StatusPreconditionFailed           = 412
 StatusRequestEntityTooLarge        = 413
 StatusRequestURITooLong            = 414
 StatusUnsupportedMediaType         = 415
 StatusRequestedRangeNotSatisfiable = 416
 StatusExpectationFailed            = 417
 StatusInternalServerError          = 500
 StatusNotImplemented               = 501
 StatusBadGateway                   = 502
 StatusServiceUnavailable           = 503
 StatusGatewayTimeout               = 504
 StatusHTTPVersionNotSupported      = 505
)
</pre>
<p>
Commonly used protocol versions in format returned by the ProtocolVersion
function.
</p>

<pre>
const (
 ProtocolVersion10 = 1000 // HTTP/1.0
 ProtocolVersion11 = 1001 // HTTP/1.1
)
</pre>
<p>
ContentTypeHTML is the content type for UTF-8 encoded HTML.
</p>

<pre>
const ContentTypeHTML = &#34;text/html; charset=\&#34;utf-8\&#34;&#34;
</pre>
<p>
TimeLayout is the time layout used for HTTP headers and other values.
</p>

<pre>
const TimeLayout = &#34;Mon, 02 Jan 2006 15:04:05 GMT&#34;
</pre>

<h2 id="variables">Variables</h2>

<pre>
var (
 ErrInvalidState          = os.NewError(&#34;object in invalid state&#34;)
 ErrBadFormat             = os.NewError(&#34;bad data format&#34;)
 ErrRequestEntityTooLarge = os.NewError(&#34;HTTP request entity too large&#34;)
)
</pre>

<pre>
var (
 ErrLineTooLong    = os.NewError(&#34;HTTP header line too long&#34;)
 ErrBadHeaderLine  = os.NewError(&#34;could not parse HTTP header line&#34;)
 ErrHeaderTooLong  = os.NewError(&#34;HTTP header value too long&#34;)
 ErrHeadersTooLong = os.NewError(&#34;too many HTTP headers&#34;)
)
</pre>

<pre>
var ErrNotMultipartFormData = os.NewError(&#34;twister: request not multipart/form-data&#34;)
</pre>

<h2 id="CheckXSRF">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L437">CheckXSRF</a></h2>
<p><code>func CheckXSRF(req *Request, cookieName string, paramName string) os.Error</code></p>
<p>
CheckXSRF implements cross-site request forgery protection. Here&#39;s how it works:
</p>
<p>
CheckXSRF sets a cookie with name cookieName to a random token.
</p>
<p>
The application ensures that POSTed forms include a parameter with name
paramName and value equal to the token.
</p>
<p>
POSTed forms are considered valid if the cookieName cookie is set and is
equal to the paramName request parameter. A third party site cannot generate
a request where the cookie and request parameter are equal because the third
party site cannot access the cookie value.
</p>
<p>
CheckXSRF returns an error if the request is not valid. It is the applications&#39;s
responsiblity to respond to the request with an appropriate error.
</p>
<p>
Before returning, CheckXSRF ensures that the paramName request parameter is
set to the token. The application should use the value of the paramName
parameter when generating hidden fields in POSTed forms.
</p>
<p>
CheckXSRF also validates PUT and DELETE requests.
</p>
<p>
The X-XSRFToken can be used to specifiy the token in addition to the
paramName request parameter.
</p>
<p>
See <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">http://en.wikipedia.org/wiki/Cross-site_request_forgery</a> for information
on cross-site request forgery.
</p>

<h2 id="FilterRespond">func <a href="http://github.com/garyburd/twister/blob/master/web/middleware.go#L34">FilterRespond</a></h2>
<p><code>func FilterRespond(req *Request, filter func(status int, header Header) (int, Header))</code></p>
<p>
FilterRespond replaces the request&#39;s responder with one that filters the
arguments to Respond through the supplied filter. This function is intended
to be used by middleware.
</p>

<h2 id="FormatDeltaDays">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L41">FormatDeltaDays</a></h2>
<p><code>func FormatDeltaDays(delta int) string</code></p>
<p>
FormatDeltaDays returns current time plus delta formatted per HTTP conventions.
</p>

<h2 id="FormatDeltaSeconds">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L36">FormatDeltaSeconds</a></h2>
<p><code>func FormatDeltaSeconds(delta int) string</code></p>
<p>
FormatDeltaSeconds returns current time plus delta formatted per HTTP conventions.
</p>

<h2 id="HTMLEscapeString">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L375">HTMLEscapeString</a></h2>
<p><code>func HTMLEscapeString(s string) string</code></p>
<p>
HTMLEscapeString returns s with special HTML characters escaped.
</p>

<h2 id="HeaderName">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L412">HeaderName</a></h2>
<p><code>func HeaderName(name string) string</code></p>
<p>
HeaderName returns the canonical format of the header name.
</p>

<h2 id="HeaderNameBytes">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L418">HeaderNameBytes</a></h2>
<p><code>func HeaderNameBytes(p []byte) string</code></p>
<p>
HeaderNameBytes returns the canonical format for the header name specified
by the bytes in p. This function modifies the contents p.
</p>

<h2 id="ParseMultipartForm">func <a href="http://github.com/garyburd/twister/blob/master/web/multipart.go#L55">ParseMultipartForm</a></h2>
<p><code>func ParseMultipartForm(req *Request, maxRequestBodyLen int) ([]Part, os.Error)</code></p>
<p>
ParseMultipartForm parses a multipart/form-data body. Form fields are
added to the request Param. This function loads the entire request body in
memory. This may not be appropriate in some scenarios.
</p>

<h2 id="ProtocolVersion">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L149">ProtocolVersion</a></h2>
<p><code>func ProtocolVersion(major int, minor int) int</code></p>
<p>
ProtocolVersion combines HTTP major and minor protocol numbers into a single
integer for easy comparision of protocol versions.
</p>

<h2 id="QuoteHeaderValue">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L436">QuoteHeaderValue</a></h2>
<p><code>func QuoteHeaderValue(s string) string</code></p>
<p>
QuoteHeaderValue quotes s using quoted-string rules described in RFC 2616.
</p>

<h2 id="QuoteHeaderValueOrToken">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L452">QuoteHeaderValueOrToken</a></h2>
<p><code>func QuoteHeaderValueOrToken(s string) string</code></p>
<p>
QuoteHeaderValueOrToken quotes s if s is not a valid token per RFC 2616.
</p>

<h2 id="RunHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/test.go#L106">RunHandler</a></h2>
<p><code>func RunHandler(url string, method string, reqHeader Header, reqBody []byte, handler Handler) (status int, header Header, respBody []byte)</code></p>
<p>
RunHandler runs the handler with a request created from the arguments and
returns the response. This function is intended to be used in tests.
</p>

<h2 id="ServeFile">func <a href="http://github.com/garyburd/twister/blob/master/web/handlers.go#L40">ServeFile</a></h2>
<p><code>func ServeFile(req *Request, fname string, options *ServeFileOptions)</code></p>
<p>
ServeFile responds to the request with the contents of the named file.
</p>
<p>
If the &#34;v&#34; request parameter is set, then ServeFile sets the expires header
and the cache control maximum age parameter to ten years in the future.
</p>

<h2 id="SignValue">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L240">SignValue</a></h2>
<p><code>func SignValue(secret, context string, maxAgeSeconds int, value string) string</code></p>
<p>
SignValue returns a string containing value, an expiration time and a
signature. The expiration time is computed from the current time and
maxAgeSeconds.  The signature is an HMAC SHA-1 signature of value, context
and the expiration time. Use the function VerifyValue to extract the value,
check the expiration time and verify the signature.
</p>
<p>
SignValue can be used to store credentials in a cookie:
</p>
<pre>var secret string // Initialized by application
const uidCookieMaxAge = 3600 * 24 * 30

// uidCookieValue returns the Set-Cookie header value containing a
// signed and timestamped user id.
func uidCookieValue(uid string) string {
    s := web.SignValue(secret, &#34;uid&#34;, uidCookieMaxAge, uid)
    return web.NewCookie(&#34;uid&#34;, s).MaxAge(uidCookieMaxAge).String()
}

// requestUid returns the user id from the request cookie. An error
// is returned if the cookie is missing, the value has expired or the
// signature is not valid.
func requestUid(req *web.Request) (string, os.Error) {
    return web.VerifyValue(secret, &#34;uid&#34;, req.Cookie.Get(&#34;uid&#34;))
}
</pre>

<h2 id="StatusText">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L139">StatusText</a></h2>
<p><code>func StatusText(status int) string</code></p>
<p>
StatusText returns a text description of an HTTP status code.
</p>

<h2 id="UnquoteHeaderValue">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L463">UnquoteHeaderValue</a></h2>
<p><code>func UnquoteHeaderValue(s string) string</code></p>
<p>
UnquoteHeaderValue unquotes s if s is surrounded by quotes, otherwise s is
returned.
</p>

<h2 id="VerifyValue">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L250">VerifyValue</a></h2>
<p><code>func VerifyValue(secret, context string, signedValue string) (string, os.Error)</code></p>
<p>
VerifyValue extracts a value from a string created by SignValue. An error is
returned if the expiration time has elapsed or the signature is not correct.
</p>


<h2 id="Cookie">type Cookie</h2>
<p>
Cookie is a helper for constructing Set-Cookie header values.
</p>
<p>
Cookie supports the ancient Netscape draft specification for cookies
(<a href="http://goo.gl/1WSx3">http://goo.gl/1WSx3</a>) and the modern HttpOnly attribute
(<a href="http://www.owasp.org/index.php/HttpOnly">http://www.owasp.org/index.php/HttpOnly</a>). Cookie does not attempt to
support any RFC for cookies because the RFCs are not supported by popular
browsers.
</p>
<p>
As a convenience, the NewCookie function returns a cookie with the path
attribute set to &#34;/&#34; and the httponly attribute set to true.
</p>
<p>
The following example shows how to set a cookie header using Cookie:
</p>
<pre>func myHandler(req *web.Request) {
    c := web.NewCookie(&#34;my-cookie-name&#34;, &#34;my-cookie-value&#34;).String()
    w := req.Respond(web.StatusOK, web.HeaderSetCookie, c)
    io.WriteString(w, &#34;&lt;html&gt;&lt;body&gt;Hello&lt;/body&gt;&lt;/html&gt;&#34;)
}
</pre>

<pre>type Cookie struct {
 // contains filtered or unexported fields
}</pre>



    <h3 id="NewCookie">func <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L305">NewCookie</a></h3>
    <p><code>func NewCookie(name, value string) *Cookie</code></p>
    <p>
NewCookie returns a new cookie with the given name and value, the path
attribute set to &#34;/&#34; and the httponly attribute set to true.
</p>


    <h3 id="Cookie.Delete">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L328">Delete</a></h3>
    <p><code>func (c *Cookie) Delete() *Cookie</code></p>
    <p>
Delete sets the expiration date to a time in the past.
</p>

    <h3 id="Cookie.Domain">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L316">Domain</a></h3>
    <p><code>func (c *Cookie) Domain(domain string) *Cookie</code></p>
    <p>
Domain sets the cookie domain attribute. If the host is &#34;&#34;, then the domain
attribute is not included in the header value.
</p>

    <h3 id="Cookie.HTTPOnly">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L335">HTTPOnly</a></h3>
    <p><code>func (c *Cookie) HTTPOnly(httpOnly bool) *Cookie</code></p>
    <p>
HTTPOnly sets the httponly attribute. The NewCookie function
initializes the httponly attribute to true.
</p>

    <h3 id="Cookie.MaxAge">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L322">MaxAge</a></h3>
    <p><code>func (c *Cookie) MaxAge(seconds int) *Cookie</code></p>
    <p>
MaxAge specifies the maximum age for a cookie. The age is converted to an
absolute expiration time when the header value is rendered. If the maximum
age is 0, then the expiration time is not included in the header value
and the browser will handle the cookie as a &#34;session&#34; cookie.
</p>

    <h3 id="Cookie.MaxAgeDays">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L325">MaxAgeDays</a></h3>
    <p><code>func (c *Cookie) MaxAgeDays(days int) *Cookie</code></p>
    <p>
MaxAgeDays sets the maximum age for the cookie in days.
</p>

    <h3 id="Cookie.Path">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L312">Path</a></h3>
    <p><code>func (c *Cookie) Path(path string) *Cookie</code></p>
    <p>
Path sets the cookie path attribute. The path must either be &#34;&#34; or start with a
&#39;/&#39;.  The NewCookie function initializes the path to &#34;/&#34;. If the path is &#34;&#34;,
then the path attribute is not included in the header value.
</p>

    <h3 id="Cookie.Secure">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L331">Secure</a></h3>
    <p><code>func (c *Cookie) Secure(secure bool) *Cookie</code></p>
    <p>
Secure sets the secure attribute.
</p>

    <h3 id="Cookie.String">func (*Cookie) <a href="http://github.com/garyburd/twister/blob/master/web/misc.go#L341">String</a></h3>
    <p><code>func (c *Cookie) String() string</code></p>
    <p>
String renders the Set-Cookie header value as a string.
</p>


<h2 id="ErrorHandler">type ErrorHandler</h2>
<p>
ErrorHandler handles request errors.
</p>

<pre>type ErrorHandler func(req *Request, status int, reason os.Error, header Header)</pre>





<h2 id="Flusher">type Flusher</h2>
<p>
Flusher is implemented by response bodies that allow the HTTP handler to
flush buffered data to the network. Flush data to the network is useful for
implementing long polling and other Comet mechanisms.
</p>

<pre>type Flusher interface {
 Flush() os.Error
}</pre>





<h2 id="Handler">type Handler</h2>
<p>
Handler is the interface for web handlers.
</p>

<pre>type Handler interface {
 ServeWeb(req *Request)
}</pre>



    <h3 id="DirectoryHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/handlers.go#L135">DirectoryHandler</a></h3>
    <p><code>func DirectoryHandler(root string, options *ServeFileOptions) Handler</code></p>
    <p>
DirectoryHandler returns a request handler that serves static files from root
using using the relative request parameter &#34;path&#34;. The &#34;path&#34; parameter is
typically set using a Router pattern match:
</p>
<pre>r.Register(&#34;/static/&lt;path:.*&gt;&#34;, &#34;GET&#34;, DirectoryHandler(root))
</pre>
<p>
Directory handler does not serve directory listings.
</p>

    <h3 id="FileHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/handlers.go#L171">FileHandler</a></h3>
    <p><code>func FileHandler(fname string, options *ServeFileOptions) Handler</code></p>
    <p>
FileHandler returns a request handler that serves a static file specified by
fname.
</p>

    <h3 id="FormHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/middleware.go#L131">FormHandler</a></h3>
    <p><code>func FormHandler(maxRequestBodyLen int, checkXSRF bool, h Handler) Handler</code></p>
    <p>
FormHandler returns a handler that parses form encoded request bodies.
</p>
<p>
If xsrfCheck is true, then cross-site request forgery protection is enabled
using the cookie name XSRFCookieName and the parameter name
XSRFParameterName. See CheckXSRF() for more information on cross-site
request forgery protection.
</p>

    <h3 id="NotFoundHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/handlers.go#L202">NotFoundHandler</a></h3>
    <p><code>func NotFoundHandler() Handler</code></p>
    <p>
NotFoundHandler returns a request handler that responds with 404 not found.
</p>

    <h3 id="ProxyHeaderHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/middleware.go#L94">ProxyHeaderHandler</a></h3>
    <p><code>func ProxyHeaderHandler(addrName, schemeName string, h Handler) Handler</code></p>
    <p>
ProxyHeaderHandler returns a handler that overrides the Request.RemoteAddr field
with the value of the header specified by addrName and the
Request.URL.Scheme field with the value of the header specified by
schemeName. No fix up is done for a field if the header name equals &#34;&#34; or the
header is not present.
</p>
<p>
The header names must be in canonical header name format.
</p>
<p>
Here&#39;s an example of how to use this handler with Nginx. In the nginx proxy
configuration, specify a header for the IP address and scheme. The host
header should also be passed through the proxy:
</p>
<pre>location / {
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Scheme $scheme;
    proxy_set_header Host $http_host;
    proxy_pass <a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a>;
}
</pre>
<p>
In the main function for the application, wrap the application handler with
the proxy fix up:
</p>
<pre> import (
     &#34;github.com/garyburd/twister/web&#34;
     &#34;github.com/garyburd/twister/server&#34;
 )

 func main() {
     var h web.Handler
     ... setup the application handler
     h = web.ProxyHeaderHandler(&#34;X-Scheme&#34;, &#34;X-Real-Ip&#34;, h)
	    server.Run(&#34;:8080&#34;, h)
 }
</pre>

    <h3 id="RedirectHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/handlers.go#L195">RedirectHandler</a></h3>
    <p><code>func RedirectHandler(url string, permanent bool) Handler</code></p>
    <p>
RedirectHandler returns a request handler that redirects to the given URL.
</p>

    <h3 id="SetErrorHandler">func <a href="http://github.com/garyburd/twister/blob/master/web/middleware.go#L39">SetErrorHandler</a></h3>
    <p><code>func SetErrorHandler(e ErrorHandler, h Handler) Handler</code></p>
    <p>
SetErrorHandler returns a handler that sets the request&#39;s error handler e.
</p>



<h2 id="HandlerFunc">type HandlerFunc</h2>
<p>
HandlerFunc is a type adapter to allow the use of ordinary functions as web
handlers. If the function returns an error, then the adapter responds to the
request with an error response.
</p>

<pre>type HandlerFunc func(*Request)</pre>




    <h3 id="HandlerFunc.ServeWeb">func (HandlerFunc) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L113">ServeWeb</a></h3>
    <p><code>func (f HandlerFunc) ServeWeb(req *Request)</code></p>
    <p>
ServeWeb calls f(req).
</p>


<h2 id="Header">type Header</h2>
<p>
Header maps header names to a slice of header values.
</p>
<p>
The header names must be in canonical format: the first letter and letters
following &#39;-&#39; are uppercase and all other letters are lowercase.  The
Header* constants are in canonical format. Use the function HeaderName to
convert a string to canonical format.
</p>

<pre>type Header map[string][]string</pre>



    <h3 id="NewHeader">func <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L76">NewHeader</a></h3>
    <p><code>func NewHeader(kvs ...string) Header</code></p>
    <p>
NewHeader returns a map initialized with the given key-value pairs.
</p>


    <h3 id="Header.Add">func (Header) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L88">Add</a></h3>
    <p><code>func (m Header) Add(key string, value string)</code></p>
    <p>
Add appends value to slice for given key.
</p>

    <h3 id="Header.Get">func (Header) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L98">Get</a></h3>
    <p><code>func (m Header) Get(key string) string</code></p>
    <p>
Get returns the first value for given key or &#34;&#34; if the key is not found.
</p>

    <h3 id="Header.GetAccept">func (Header) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L187">GetAccept</a></h3>
    <p><code>func (m Header) GetAccept(key string) []ValueParams</code></p>
    <p>
GetAccept returns a parsed Accept-* header in descending quality order.
</p>

    <h3 id="Header.GetList">func (Header) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L118">GetList</a></h3>
    <p><code>func (m Header) GetList(key string) []string</code></p>
    <p>
GetList returns list of comma separated values over multiple header values
for the given key. Commas are ignored in quoted strings. Quoted values are
not unescaped or unquoted. Whitespace is trimmmed.
</p>

    <h3 id="Header.GetValueParam">func (Header) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L110">GetValueParam</a></h3>
    <p><code>func (m Header) GetValueParam(key string) (value string, param map[string]string)</code></p>
    <p>
GetValueParam returns a value and optional semi-colon prefixed name-value
pairs for header with name key. The value and parameter keys are converted
to lowercase. All whitespace is trimmed. This format is used by the
Content-Type and Content-Disposition headers.
</p>

    <h3 id="Header.ParseHttpHeader">func (Header) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L232">ParseHttpHeader</a></h3>
    <p><code>func (m Header) ParseHttpHeader(br *bufio.Reader) (err os.Error)</code></p>
    <p>
ParseHttpHeader parses the HTTP headers and appends the values to the
supplied map. Header names are converted to canonical format.
</p>

    <h3 id="Header.Set">func (Header) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L93">Set</a></h3>
    <p><code>func (m Header) Set(key string, value string)</code></p>
    <p>
Set value for given key, discarding previous values if any.
</p>

    <h3 id="Header.WriteHttpHeader">func (Header) <a href="http://github.com/garyburd/twister/blob/master/web/headermap.go#L200">WriteHttpHeader</a></h3>
    <p><code>func (m Header) WriteHttpHeader(w io.Writer) os.Error</code></p>
    <p>
WriteHttpHeader writes the map in HTTP header format.
</p>


<h2 id="HostRouter">type HostRouter</h2>
<p>
HostRouter dispatches HTTP requests to a handler using the host HTTP header.
</p>
<p>
A host router maintains a list of routes where each route is a (pattern,
handler) pair.  The router dispatches requests by matching the host header
against the patterns in the order that the routes were registered. If a
matching route is found, the request is dispatched to the route&#39;s handler.
</p>
<p>
A pattern is a string with embedded parameters. A parameter has the syntax:
</p>
<pre>&#39;&lt;&#39; name (&#39;:&#39; regexp)? &#39;&gt;&#39;
</pre>
<p>
If the regexp is not specified, then the regexp is set to to [^.]+.  The
host router adds the parameters to the request Param.
</p>

<pre>type HostRouter struct {
 // contains filtered or unexported fields
}</pre>



    <h3 id="NewHostRouter">func <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L226">NewHostRouter</a></h3>
    <p><code>func NewHostRouter(defaultHandler Handler) *HostRouter</code></p>
    <p>
NewHostRouter allocates and initializes a new HostRouter.
</p>


    <h3 id="HostRouter.Register">func (*HostRouter) <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L234">Register</a></h3>
    <p><code>func (router *HostRouter) Register(hostPattern string, handler Handler) *HostRouter</code></p>
    <p>
Register a handler for the given pattern.
</p>

    <h3 id="HostRouter.ServeWeb">func (*HostRouter) <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L253">ServeWeb</a></h3>
    <p><code>func (router *HostRouter) ServeWeb(req *Request)</code></p>
    <p>
ServeWeb dispatches the request to a registered handler.
</p>


<h2 id="MultipartReader">type MultipartReader</h2>
<p>
MultipartReader reads a multipart/form-data request body.
</p>

<pre>type MultipartReader struct {
 // contains filtered or unexported fields
}</pre>



    <h3 id="NewMultipartReader">func <a href="http://github.com/garyburd/twister/blob/master/web/multipart.go#L109">NewMultipartReader</a></h3>
    <p><code>func NewMultipartReader(req *Request, maxRequestBodyLen int) (*MultipartReader, os.Error)</code></p>
    <p>
NewMultipartReader returns a a multipart/form-data reader.
</p>


    <h3 id="MultipartReader.Next">func (*MultipartReader) <a href="http://github.com/garyburd/twister/blob/master/web/multipart.go#L154">Next</a></h3>
    <p><code>func (m *MultipartReader) Next() (Header, io.Reader, os.Error)</code></p>
    <p>
Next returns the next part of a multipart/form-data body.  Next returns
os.EOF if no more parts remain.
</p>


<h2 id="Part">type Part</h2>
<p>
Part represents an element of a multi-part request entity.
</p>

<pre>type Part struct {
 Name         string
 Filename     string
 ContentType  string
 ContentParam map[string]string
 Data         []byte
}</pre>





<h2 id="Request">type Request</h2>
<p>
Request represents an HTTP request to the server.
</p>

<pre>type Request struct {
 // The response.
 Responder Responder

 // Uppercase request method. GET, POST, etc.
 Method string

 // The request URL with host and scheme set appropriately.
 URL *http.URL

 // Protocol version: major version * 1000 + minor version	
 ProtocolVersion int

 // The IP address of the client sending the request to the server.
 RemoteAddr string

 // Header maps canonical header names to slices of header values.
 Header Header

 // Request params from the query string, post body, routers and other.
 Param Values

 // Cookies.
 Cookie Values

 // Lowercase content type, not including params.
 ContentType string

 // Parameters from Content-Type header
 ContentParam map[string]string

 // ErrorHandler responds to the request with the given status code.
 // Applications can set the error handler using middleware. 
 ErrorHandler ErrorHandler

 // ContentLength is the length of the request body or -1 if the content
 // length is not known.
 ContentLength int

 // The request body.
 Body io.Reader

 // Attributes attached to the request by middleware. 
 Env map[string]interface{}
}</pre>



    <h3 id="NewRequest">func <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L117">NewRequest</a></h3>
    <p><code>func NewRequest(remoteAddr string, method string, url *http.URL, protocolVersion int, header Header) (req *Request, err os.Error)</code></p>
    <p>
NewRequest allocates and initializes a request. This function is provided
for the convenience of protocol adapters (fcgi, native http server, ...).
</p>


    <h3 id="Request.BodyBytes">func (*Request) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L197">BodyBytes</a></h3>
    <p><code>func (req *Request) BodyBytes(maxLen int) ([]byte, os.Error)</code></p>
    <p>
BodyBytes returns the request body a slice of bytes. If maxLen is negative,
then no limit is imposed on the length of the body. If the body is longer
than maxLen, then ErrRequestEntityTooLarge is returned.
</p>

    <h3 id="Request.Error">func (*Request) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L171">Error</a></h3>
    <p><code>func (req *Request) Error(status int, reason os.Error, headerKeysAndValues ...string)</code></p>
    <p>
Error responds to the request with an error.
</p>

    <h3 id="Request.ParseForm">func (*Request) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L229">ParseForm</a></h3>
    <p><code>func (req *Request) ParseForm(maxRequestBodyLen int) os.Error</code></p>
    <p>
ParseForm parses url-encoded form bodies. ParseForm is idempotent. Most
applications should use the FormHandler middleware instead of calling this
method directly.
</p>

    <h3 id="Request.Redirect">func (*Request) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L176">Redirect</a></h3>
    <p><code>func (req *Request) Redirect(url string, perm bool, headerKeysAndValues ...string)</code></p>
    <p>
Redirect responds to the request with a redirect to the specified URL.
</p>

    <h3 id="Request.Respond">func (*Request) <a href="http://github.com/garyburd/twister/blob/master/web/web.go#L157">Respond</a></h3>
    <p><code>func (req *Request) Respond(status int, headerKeysAndValues ...string) io.Writer</code></p>
    <p>
Respond is a convenience function that adds (key, value) pairs in
headerKeysAndValues to a Header and calls through to the responder&#39;s
Respond method.
</p>


<h2 id="Responder">type Responder</h2>
<p>
Responder represents the response.
</p>

<pre>type Responder interface {
 // Respond commits the status and headers to the network and returns
 // a writer for the response body.
 Respond(status int, header Header) (responseBody io.Writer)

 // Hijack lets the caller take over the connection from the HTTP server.
 // The caller is responsible for closing the connection. Returns connection
 // and bufio Reader with any data that might be buffered by the server.
 // Hijack is not supported by all servers.
 Hijack() (conn net.Conn, br *bufio.Reader, err os.Error)
}</pre>





<h2 id="Router">type Router</h2>
<p>
Router dispatches HTTP requests to a handler using the path component of the
request URL and the request method.
</p>
<p>
A router maintains a list of routes. A route consists of a request path
pattern and a collection of (method, handler) pairs.
</p>
<p>
A pattern is a string with embedded parameters. A parameter has the syntax:
</p>
<pre>&#39;&lt;&#39; name (&#39;:&#39; regexp)? &#39;&gt;&#39;
</pre>
<p>
If the regexp is not specified, then the regexp is set to to [^/]+.
</p>
<p>
The pattern must begin with the character &#39;/&#39;.
</p>
<p>
A router dispatches requests by matching the path component of the request
URL against the route patterns in the order that the routes were registered.
If a matching route is found, then the router searches the route for a
handler using the request method, &#34;GET&#34; if the request method is &#34;HEAD&#34; and
&#34;*&#34;. If a handler is not found, the router responds with HTTP status 405. If
a route is not found, then the router responds with HTTP status 404.
</p>
<p>
The handler can access the path parameters in the request Param.
</p>
<p>
If a pattern ends with &#39;/&#39;, then the router redirects the URL without the
trailing slash to the URL with the trailing slash.
</p>

<pre>type Router struct {
 // contains filtered or unexported fields
}</pre>



    <h3 id="NewRouter">func <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L197">NewRouter</a></h3>
    <p><code>func NewRouter() *Router</code></p>
    <p>
NewRouter allocates and initializes a new Router.
</p>


    <h3 id="Router.Register">func (*Router) <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L107">Register</a></h3>
    <p><code>func (router *Router) Register(pattern string, handlers ...interface{}) *Router</code></p>
    <p>
Register the route with the given pattern and handlers. The structure of the
handlers argument is:
</p>
<p>
(method handler)+
</p>
<p>
where method is a string and handler is a Handler or a
func(*Request). Use &#34;*&#34; to match all methods.
</p>

    <h3 id="Router.ServeWeb">func (*Router) <a href="http://github.com/garyburd/twister/blob/master/web/router.go#L188">ServeWeb</a></h3>
    <p><code>func (router *Router) ServeWeb(req *Request)</code></p>
    <p>
ServeWeb dispatches the request to a registered handler.
</p>


<h2 id="ServeFileOptions">type ServeFileOptions</h2>

<pre>type ServeFileOptions struct {
 // Map file extension to mime type.
 MimeType map[string]string

 // Response headers. 
 Header Header
}</pre>





<h2 id="ValueParams">type ValueParams</h2>
<p>
ValueParams represents a value with parameters.
</p>

<pre>type ValueParams struct {
 Value string
 Param map[string]string
}</pre>





<h2 id="Values">type Values</h2>
<p>
Values maps names to slices of values.
</p>

<pre>type Values map[string][]string</pre>



    <h3 id="NewValues">func <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L27">NewValues</a></h3>
    <p><code>func NewValues(kvs ...string) Values</code></p>
    <p>
NewValues returns a map initialized with the given key-value pairs.
</p>


    <h3 id="Values.Add">func (Values) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L48">Add</a></h3>
    <p><code>func (m Values) Add(key string, value string)</code></p>
    <p>
Add appends value to slice for given key.
</p>

    <h3 id="Values.FormEncodedBytes">func (Values) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L69">FormEncodedBytes</a></h3>
    <p><code>func (m Values) FormEncodedBytes() []byte</code></p>
    <p>
FormEncodedBytes returns a buffer containing the URL form encoding of the
map.
</p>

    <h3 id="Values.FormEncodedString">func (Values) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L90">FormEncodedString</a></h3>
    <p><code>func (m Values) FormEncodedString() string</code></p>
    <p>
FormEncodedString returns a string containing the URL form encoding of the
map.
</p>

    <h3 id="Values.Get">func (Values) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L39">Get</a></h3>
    <p><code>func (m Values) Get(key string) string</code></p>
    <p>
Get returns the first value for given key or &#34;&#34; if the key is not found.
</p>

    <h3 id="Values.ParseFormEncodedBytes">func (Values) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L110">ParseFormEncodedBytes</a></h3>
    <p><code>func (m Values) ParseFormEncodedBytes(p []byte) os.Error</code></p>
    <p>
ParseFormEncodedBytes parses the URL-encoded form and appends the values to
the supplied map. This function modifies the contents of p.
</p>

    <h3 id="Values.Set">func (Values) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L53">Set</a></h3>
    <p><code>func (m Values) Set(key string, value string)</code></p>
    <p>
Set value for given key, discarding previous values if any.
</p>

    <h3 id="Values.StringMap">func (Values) <a href="http://github.com/garyburd/twister/blob/master/web/parammap.go#L59">StringMap</a></h3>
    <p><code>func (m Values) StringMap() map[string]string</code></p>
    <p>
StringMap returns a string to string map by discarding all but the first
value for a key.
</p>


<hr>
This page was generated automatically from the source code. If you installed
Twister using <a href="http://golang.org/cmd/goinstall/">goinstall</a>, then
you can also view the source documentation with <a
href="http://golang.org/cmd/godoc/">godoc</a>.  
</div>
</body>
</html>
